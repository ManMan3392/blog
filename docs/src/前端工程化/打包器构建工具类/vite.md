# vite

## 前端工程化痛点及解决方案

1. 模块化需求：
   提供模块加载方案，并兼容不同的模块规范
2. 兼容浏览器，编译高级语法
   配合 Sass、TSC、Babel 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。
3. 线上代码的质量问题，考虑代码运行时的性能问题
   生产环境配合 Terser 等压缩工具进行代码压缩和混淆，通过 Tree Shaking 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。
4. 开发效率，项目的冷启动/二次启动时间、热更新时间
   构建工具性能优化

## vite 简介

vite 是一种新型前端构建工具，Vite 能将项目的启动性能提升一个量级，并且达到毫秒级的瞬间热更新效果。
它主要由两部分组成：
一个开发服务器，它基于**原生 ES 模块**提供了丰富的内建功能，在开发过程中，Vite 假设使用的是现代浏览器。这意味着该浏览器支持大多数最新的 JavaScript 和 CSS 功能。因此，Vite 将 esnext 设置为转换目标。基于浏览器原生 ESM 的支持实现了 no-bundle 服务。这可以**防止语法降低**，使 Vite 能够尽可能接近原始源代码提供模块。这就是 vite 构建速度快原因之一。在开发环境做第三方库构建和 TS/JSX 语法编译时，vite 采用<a href='./esbuild.md'>esbuild</a>，一个基于 Go 语言的打包工具，打包速度快。

一套构建指令，在生产打包时，Vite 采用了<a href='./rollup.md'>Rollup</a>灵活的插件 API 和基础建设，能够输出高度优化的静态资源。虽然 Rollup 速度没有 esbuild 快，但它已经开始着手改进性能，在 v4 中将其解析器切换到<a href='../语法转换编译类/swc.md'>SWC</a>。同时还有一个正在进行中的工作，即构建一个名为<a href='./rolldown.md'> Rolldown </a>的 Rust 版本的 Rollup。一旦 Rolldown 准备就绪，它就可以在 Vite 中取代 Rollup 和 esbuild，显著提高构建性能，并消除开发和构建之间的不一致性。

## vite 的基本使用

因为 vite 采用预配置的方式，所以使用 vite 时，需要配置的地方少之又少，基本开箱即用。
下面是 vite 使用时安装的一些环境及命令，可以看到 vite 并不需要配置太多的插件，内部已经完善好了。命令也相当简单。
[手动构建 vite 项目示例](https://github.com/ManMan3392/redrockhomework/tree/main/vite)
除此之外，我们还可以运用 vite 的脚手架创建项目，甚至连上述简单的配置都不需要我们完成。

```js
pnpm create vite
```

## 双引擎机制
![alt text](image-1.png)
### esbild
1. 开发预构建
   不预构建的问题
   - 如果让vite直接发送网络请求拿到第三方库的包，会引发数据瀑布流问题，每个import就是一个文件请求，但是 Chrome 对同一个域名下只能同时支持 6 个 HTTP 并发请求的限制，会导致页面加载十分缓慢。
   - 很多第三方库的打包都不是es版的，而vite是基于浏览器原生 ES 模块规范实现的 Dev Server，所以他们没有办法直接在vite里跑。
  所以vite使用esbuild来进行依赖预构建，虽然esbuild因基于go语言开发等原因有极快的打包速度，但他也有很多缺点：
  - 不支持降级到 ES5 的代码。这意味着在低端浏览器代码会跑不起来。
  - 不支持 const enum 等语法。这意味着单独使用这些语法在 esbuild 中会直接抛错。
  - 不提供操作打包产物的接口，像 Rollup 中灵活处理打包产物的能力(如renderChunk钩子)在 Esbuild 当中完全没有。
  - 不支持自定义 Code Splitting 策略。传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 Esbuild 并未提供，从而降级了拆包优化的灵活性。
  所以vite在生产环境选择使用更成熟全面的打包工具rollup。
  
2. 单文件编译工具(ts/jsx)
   在 TS(X)/JS(X) 单文件编译上面，Vite 也使用 Esbuild 进行语法转译，也就是将 Esbuild 作为 Transformer 来用。但是Esbuild 并没有实现 TS 的类型系统，在编译ts时会抹掉相关代码，所以vite选择先用tsc实现类型检查，只输出错误但是不生成对应的js产物。
3. 代码压缩
   生产环境中 Esbuild 压缩器通过插件的形式融入到了 Rollup 的打包流程中。
   相比于传统的压缩工具类似于terser,esbuild有很大的速度优势，理由如下：
   - 压缩这项工作涉及大量 AST 操作，并且在传统的构建流程中，AST 在各个工具之间无法共享，比如 Terser 就无法与 Babel 共享同一个 AST，造成了很多重复解析的过程。但esbuild从头到尾都使用共享 AST 。
   - JS 本身属于解释性 + JIT（即时编译） 的语言，对于压缩这种 CPU 密集型的工作，其性能远远比不上 Golang 这种原生语言。


### rollup
是 Vite 用作生产环境打包的核心工具，也直接决定了 Vite 插件机制的设计。
1. 生产环境的bundle
   尽管esm得到了大部分浏览器的支持，但是生产环境为了适配市面上的浏览器，vite还是使用了rollup进行打包，并基于 Rollup 本身成熟的打包能力进行扩展和优化。
   主要体现在下面三个方面：
   - CSS 代码分割。如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的缓存复用率。
   - 自动预加载。vite自动为入口 chunk 的依赖自动生成预加载标签<link rel="modulepreload">,会让浏览器提前下载好资源，优化页面性能。
   - 异步 Chunk 加载优化。一般情况下，在异步引入的 Chunk 中,浏览器碰见请求后才加载被依赖的模块，但是vite优化后，可以在加载模块时自动预加载他依赖的模块，节省不必要的网络开销。
2. 兼容插件机制
   在开发阶段，Vite 借鉴了 WMR 的思路，自己实现了一个 Plugin Container，用来模拟 Rollup 调度各个 Vite 插件的执行逻辑，而 Vite 的插件写法完全兼容 Rollup，因此在生产环境中将所有的 Vite 插件传入 Rollup 也没有问题。 Vite 的做法是从头到尾根植于的 Rollup 的生态，设计了和 Rollup 非常吻合的插件机制。
