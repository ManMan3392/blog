# 页面渲染流程
由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线。
按照渲染的时间顺序，流水线可分为如下几个子阶段：
构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。
- **构建DOM树**
  因为浏览器无法直接理解和使用 HTML，所以需要将HTML 转换为浏览器能够理解的结构——DOM 树。
  输入HTML 文件，然后经由HTML 解析器解析，最终输出树状结构的 DOM。
- **样式计算**
  样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成：
  1. 当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。
   ![alt text](image-17.png)
  2. 转换样式表中的属性值，使其标准化，就是将所有值转换为渲染引擎容易理解的、标准化的计算值。
   ![alt text](image-19.png)
  3. 计算出DOM树中每个节点的具体样式：
   根据CSS 的继承规则和层叠规则得到元素最后的样式，应用到DOM节点效果如下：
   ![alt text](image-20.png)
- **布局阶段**
  1. 创建布局树：
   ![alt text](image-21.png)
   在显示之前，我们还要额外地构建一棵只包含可见元素布局树。剔除掉不需要显示的结点。遍历 DOM 树中的所有可见节点，并把这些节点加到布局中。忽略掉不可见的结点。
  2. 布局计算
   得到完整的布局树后，就根据其内容计算布局树的坐标位置。在布局操作的时候，会把布局运算的结果重新写回布局树中。
- **分层**
  页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing做 z 轴排序等，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。
  如果**拥有层叠上下文属性**（确定位属性的元素、定义透明属性的元素、用 CSS 滤镜的元素等）或者是**需要剪裁（clip）的地方**（比如当文字超出盒子大小时，就产生了剪裁，这时渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。）
  ![alt text](image-22.png)
- **图层绘制**
  渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表输出。
- **栅格化（raster）操作**
  绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。
  合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256或者 512x512，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。这涉及到了跨进程操作。
  ![alt text](image-23.png)
- **合成和显示**
  一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。
