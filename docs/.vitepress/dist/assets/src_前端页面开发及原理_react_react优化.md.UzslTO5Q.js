import{_ as s,c as i,o as e,ae as t}from"./chunks/framework.Cd-3tpCq.js";const c=JSON.parse('{"title":"react优化","description":"","frontmatter":{},"headers":[],"relativePath":"src/前端页面开发及原理/react/react优化.md","filePath":"src/前端页面开发及原理/react/react优化.md"}'),l={name:"src/前端页面开发及原理/react/react优化.md"};function n(h,a,r,o,k,p){return e(),i("div",null,a[0]||(a[0]=[t(`<h1 id="react优化" tabindex="-1">react优化 <a class="header-anchor" href="#react优化" aria-label="Permalink to &quot;react优化&quot;">​</a></h1><h2 id="hook层面" tabindex="-1">hook层面 <a class="header-anchor" href="#hook层面" aria-label="Permalink to &quot;hook层面&quot;">​</a></h2><ol><li>useMemo</li><li>useCallback(1.2.详情见&#39;react中常见hook&#39;)</li><li><h3 id="useeffect依赖项优化" tabindex="-1">useEffect依赖项优化 <a class="header-anchor" href="#useeffect依赖项优化" aria-label="Permalink to &quot;useEffect依赖项优化&quot;">​</a></h3> 精确控制依赖项数组，避免不必要的副作用执行。空数组 [] 表示仅挂载时运行一次。</li><li><h3 id="usereducer-替代复杂-usestate" tabindex="-1">useReducer 替代复杂 useState <a class="header-anchor" href="#usereducer-替代复杂-usestate" aria-label="Permalink to &quot;useReducer 替代复杂 useState&quot;">​</a></h3> 对于复杂状态逻辑，使用 useReducer 可减少渲染次数。</li></ol><h2 id="代码层面" tabindex="-1">代码层面 <a class="header-anchor" href="#代码层面" aria-label="Permalink to &quot;代码层面&quot;">​</a></h2><ol><li><h3 id="列表渲染优化" tabindex="-1">列表渲染优化： <a class="header-anchor" href="#列表渲染优化" aria-label="Permalink to &quot;列表渲染优化：&quot;">​</a></h3> 为列表项添加唯一且稳定的 key，这样的话在元素渲染时进行diff算法，可以尽可能复用节点，避免不必要的重新生成，节约性能。</li><li><h3 id="代码分割-lazy-loading" tabindex="-1">代码分割（Lazy Loading） <a class="header-anchor" href="#代码分割-lazy-loading" aria-label="Permalink to &quot;代码分割（Lazy Loading）&quot;">​</a></h3> 使用 React.lazy 和 Suspense 动态加载组件，减少首屏体积。这样可以加快首屏渲染速度，给用户更好的体验感。<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LazyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lazy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./LazyComponent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fallback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LazyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div>底层实现： <ol><li><strong>创建 Lazy 组件</strong> 标记为 REACT_LAZY_TYPE，记录加载状态。</li><li><strong>触发动态加载</strong> Webpack在打包时会将动态导入（ import()）的模块拆分为独立的文件。</li><li><strong>状态管理</strong> 通过 Promise 跟踪加载状态，利用 React 的渲染机制协调异步过程。</li><li><strong>与 Suspense 协作</strong> 未完成时显示 fallback，完成后渲染组件。</li><li><strong>错误处理</strong> 通过错误边界捕获加载失败。</li></ol></li></ol>`,5)]))}const g=s(l,[["render",n]]);export{c as __pageData,g as default};
