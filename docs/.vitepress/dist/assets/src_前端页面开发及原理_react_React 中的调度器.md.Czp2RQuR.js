import{_ as a,c as l,o as t,ae as c}from"./chunks/framework.DaakH-K9.js";const b=JSON.parse('{"title":"React 中的调度器为什么没有使用浏览器内置的 requestIdleCallback","description":"","frontmatter":{},"headers":[],"relativePath":"src/前端页面开发及原理/react/React 中的调度器.md","filePath":"src/前端页面开发及原理/react/React 中的调度器.md"}'),r={name:"src/前端页面开发及原理/react/React 中的调度器.md"};function i(s,e,o,d,u,_){return t(),l("div",null,e[0]||(e[0]=[c('<h1 id="react-中的调度器为什么没有使用浏览器内置的-requestidlecallback" tabindex="-1">React 中的调度器为什么没有使用浏览器内置的 requestIdleCallback <a class="header-anchor" href="#react-中的调度器为什么没有使用浏览器内置的-requestidlecallback" aria-label="Permalink to &quot;React 中的调度器为什么没有使用浏览器内置的 requestIdleCallback&quot;">​</a></h1><h2 id="requestidlecallback-的性能与可控性不足" tabindex="-1">requestIdleCallback 的性能与可控性不足: <a class="header-anchor" href="#requestidlecallback-的性能与可控性不足" aria-label="Permalink to &quot;requestIdleCallback 的性能与可控性不足:&quot;">​</a></h2><ul><li>不稳定 各个浏览器实现不一致，有些甚至不支持。</li><li>延迟大 在高负载场景下，requestIdleCallback 可能很久都不会触发。</li><li>无法中断: 执行中无法中断，缺乏实时调度和优先级控制。</li></ul><h2 id="react-实现了更强大更细致和灵活的-协作式调度器" tabindex="-1">React 实现了更强大更细致和灵活的“协作式调度器&quot; <a class="header-anchor" href="#react-实现了更强大更细致和灵活的-协作式调度器" aria-label="Permalink to &quot;React 实现了更强大更细致和灵活的“协作式调度器&quot;&quot;">​</a></h2><p>从 React 16 开始引入 Fiber 架构，其核心就是“可中断的渲染” + “优先级调度”,(具体过程见 react 特性及 16 前后变化)为了实现：</p><ul><li>把大的更新任务拆成小片段（Fiber 单元）</li><li>每渲染一点，就让出执行权（cooperative scheduling） React 自己实现的调度器支持:</li></ul><ol><li>优先级控制:可以区分同步任务、过渡动画、用户输入、空闲任务等（React 优先级模型）</li><li>任务分片:将渲染拆成小任务，在任务间检查是否该中断。Fiber 架构把更新过程拆分成一个个“Fiber 单元”，可以中断、恢复,每执行一个 Fiber 单元后，React 会调用调度器问一句:“还来得及继续渲染吗？” <ul><li>如果时间允许 则 继续下一个节点</li><li>如果用户滑动页面 则 中断渲染，等空闲再继续</li></ul></li><li>时间切片：每执行一小段任务，就检查是否超时、是否应该继续，提升流畅度</li><li>跨平台支持：React 也用于 React Native，不依赖浏览器 API 更具通用性。</li></ol>',7)]))}const h=a(r,[["render",i]]);export{b as __pageData,h as default};
