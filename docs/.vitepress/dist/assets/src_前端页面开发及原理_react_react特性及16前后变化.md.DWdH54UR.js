import{_ as e,c as a,o as r,ae as i}from"./chunks/framework.Cd-3tpCq.js";const u=JSON.parse('{"title":"react特性及16前后变化","description":"","frontmatter":{},"headers":[],"relativePath":"src/前端页面开发及原理/react/react特性及16前后变化.md","filePath":"src/前端页面开发及原理/react/react特性及16前后变化.md"}'),l={name:"src/前端页面开发及原理/react/react特性及16前后变化.md"};function o(c,t,n,d,s,h){return r(),a("div",null,t[0]||(t[0]=[i('<h1 id="react特性及16前后变化" tabindex="-1">react特性及16前后变化 <a class="header-anchor" href="#react特性及16前后变化" aria-label="Permalink to &quot;react特性及16前后变化&quot;">​</a></h1><h2 id="react主要特性" tabindex="-1">react主要特性 <a class="header-anchor" href="#react主要特性" aria-label="Permalink to &quot;react主要特性&quot;">​</a></h2><ol><li><h3 id="组件化开发" tabindex="-1">组件化开发 <a class="header-anchor" href="#组件化开发" aria-label="Permalink to &quot;组件化开发&quot;">​</a></h3> 一个组件是 UI（用户界面）的一部分，它拥有自己的逻辑和外观。可复用。</li><li><h3 id="jsx-javascript-xml" tabindex="-1">JSX（JavaScript XML） <a class="header-anchor" href="#jsx-javascript-xml" aria-label="Permalink to &quot;JSX（JavaScript XML）&quot;">​</a></h3> React认为渲染逻辑本质上与其他UI逻辑存在内在耦合。故而出现JSX。 可以在 JS 中写 HTML 结构。JSX 会被 Babel 编译为 React.createElement() 调用。</li><li><h3 id="单向数据流" tabindex="-1">单向数据流 <a class="header-anchor" href="#单向数据流" aria-label="Permalink to &quot;单向数据流&quot;">​</a></h3> 数据自上而下流动（从父组件传到子组件），利于数据的可控性和调试。</li><li><h3 id="虚拟-dom-virtual-dom" tabindex="-1">虚拟 DOM（Virtual DOM） <a class="header-anchor" href="#虚拟-dom-virtual-dom" aria-label="Permalink to &quot;虚拟 DOM（Virtual DOM）&quot;">​</a></h3> React 会先构建一个组件对应的虚拟 DOM 树（在内存中），每次状态变更时，先在虚拟 DOM 上进行 diff 操作，再映射到真实 DOM，提高性能。</li><li><h3 id="声明式编程" tabindex="-1">声明式编程 <a class="header-anchor" href="#声明式编程" aria-label="Permalink to &quot;声明式编程&quot;">​</a></h3> 描述“做什么”而非“怎么做”。你不需要直接进行DOM操作，就可以从手动更改DOM、属性操作、事件处理中解放出来；</li></ol><h2 id="react-的-diff-算法" tabindex="-1">React 的 Diff 算法 <a class="header-anchor" href="#react-的-diff-算法" aria-label="Permalink to &quot;React 的 Diff 算法&quot;">​</a></h2><p>用于比较更新前后的虚拟 DOM 树，找出差异部分进行最小化更新。 React利用ReactElement对象组成了一个<strong>JavaScript的对象树</strong>，就是<strong>虚拟DOM（Virtual DOM）</strong>。在 props 或 state 改变时，React 会重新构建虚拟 DOM，并通过协调（Reconciliation）机制找到变化部分，最终同步到真实 DOM。 在协调阶段，React 的 Diff 算法会比较新虚拟 DOM（VDOM）与旧 Fiber 子节点的 key 和 type，判断每个节点是否可以复用、需要插入、删除或替换。对于可复用的节点，会保留原有的 DOM 并更新属性，对于不可复用的节点则标记为删除并创建新节点。</p><p>新构建的 Fiber 子节点链表（Fiber Tree）会挂载到当前节点的 .child 上，整个过程中还会为每个节点设置相应的副作用标记（flags），如 Placement、Update、Deletion 等，用于提交阶段执行实际的 DOM 操作。</p><p>如果没有 Diff 算法，React 将无法精准判断节点的变化，哪怕只是子元素位置调换，也会认为是两个全新节点，导致销毁旧节点、创建新节点，从而丧失复用性、降低性能，影响用户体验。</p><p>Diff只比较同一父节点下的子节点，不会跨层级比较，这样能减少比较范围提升性能。如果节点类型不同，产生不同的树结构。可以通过key来指定哪些节点在不同的渲染下保持稳定：</p><ol><li>React 默认按顺序比较新旧子节点，仅在节点数量较多时（如超过 32 个）才构建旧节点 Map 来优化性能；</li><li>再遍历新子节点，查找是否能复用旧节点；</li><li>匹配不到则插入新节点，匹配到了则移动或更新。</li></ol><h2 id="fiber-架构-react-16" tabindex="-1">Fiber 架构（React 16+） <a class="header-anchor" href="#fiber-架构-react-16" aria-label="Permalink to &quot;Fiber 架构（React 16+）&quot;">​</a></h2><p>React Fiber 是一个可中断、可恢复、基于优先级调度的<strong>协调引擎</strong>，它让 React 真正成为一个可控 UI 渲染引擎，不仅仅是一个视图库。</p><h3 id="react-16-后的渲染架构" tabindex="-1">React 16 后的渲染架构 <a class="header-anchor" href="#react-16-后的渲染架构" aria-label="Permalink to &quot;React 16 后的渲染架构&quot;">​</a></h3><p>React 渲染流程可以拆成<strong>三个核心部分</strong>：</p><ol><li>Scheduler（调度器）:分配时间片，调度优先级，<strong>决定何时开始执行更新任务</strong></li><li>Reconciler（协调器）:构建 Fiber 树，执行组件逻辑，生成 effectList（变更列表）</li><li>Renderer（渲染器）:把变更应用到真实平台（DOM、原生、Canvas...）</li></ol><h4 id="现在我们来看看渲染流程吧" tabindex="-1">现在我们来看看<strong>渲染流程</strong>吧！ <a class="header-anchor" href="#现在我们来看看渲染流程吧" aria-label="Permalink to &quot;现在我们来看看**渲染流程**吧！&quot;">​</a></h4><ol><li><p><strong>Render Phase（协调阶段）（使用Diff算法的地方）</strong> React 每次更新时，会用 新的 VDOM（虚拟 DOM）树 去对比 旧的 Fiber Tree，以确定要执行的更新操作。这个过程就叫 Reconciliation（协调），它的核心就是 Diff 算法。 流程如下：</p><ol><li>Scheduler 安排更新任务（setState、props变更等）入队</li><li>从 root Fiber 开始调用 beginWork（构建当前 Fiber 子节点（使用Diff算法优化，最大可能复用子节点），执行组件函数/类 render）</li><li>遍历构建新的 workInProgress Fiber 树</li><li>比较 old Fiber（current） 和 新 VDOM（next）</li><li>收集变更信息（effect）</li><li>构建完成后，等待进入 commit 阶段</li></ol><p>注意哦：这个阶段是<strong>可中断的</strong>，Fiber 架构支持可中断的协调过程，但实际是否中断取决于是否启用了并发模式（如 createRoot() 进入 Concurrent Mode）。渲染任务不会阻塞主线程，支持暂停、恢复、重试。<strong>支持优先级</strong>，重要任务先执行（例如：用户输入 &gt; 动画 &gt; 异步数据加载），如果任务超时或优先级高，会抢占当前任务，提高响应性，<strong>不操作 DOM</strong>，只是操作虚拟 DOM。</p></li><li><p><strong>Commit Phase（提交阶段）</strong> 把收集到的 effect 执行到真实 DOM 中（插入/更新/删除 DOM 元素）。 流程如下：</p><ol><li>Before Mutation</li></ol><ul><li>获取旧 DOM 信息（用于 snapshot）</li></ul><ol start="2"><li>Mutation</li></ol><ul><li>执行 DOM 操作（插入/更新/删除） 提交新的 workInProgress 树替换为 current 树</li></ul><ol start="3"><li>Layout</li></ol><ul><li>执行副作用（如 useLayoutEffect、componentDidMount）</li></ul></li></ol><p>特点：</p><ol><li>不可中断</li><li>快速完成所有 DOM 更新</li><li>最后刷新画面，触发浏览器绘制</li></ol><p>为啥要<strong>两棵树</strong>捏？只保存一个虚拟DOM不是更节约吗？ 因为两棵树可以——</p><ol><li>构建期间不中断页面展示；</li><li>可以打断/恢复更新；</li><li>有“回滚”空间。</li></ol><h2 id="react16前后对比" tabindex="-1">react16前后对比： <a class="header-anchor" href="#react16前后对比" aria-label="Permalink to &quot;react16前后对比：&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性/版本</th><th>React 16 之前</th><th>React 16（Fiber）之后</th></tr></thead><tbody><tr><td>渲染过程</td><td>同步递归，不能中断</td><td>可中断、增量、优先级调度的 Fiber 树</td></tr><tr><td>错误处理</td><td>一处出错，整个页面崩溃</td><td>引入 Error Boundaries，局部处理错误</td></tr><tr><td>渲染能力</td><td>无法中断、低优先级响应慢</td><td>可打断任务，响应用户更及时</td></tr><tr><td>支持的功能</td><td>基础渲染</td><td>支持 Suspense、Concurrent Mode 等</td></tr><tr><td>内部数据结构</td><td>虚拟 DOM 树</td><td>Fiber 树（链表结构，能记录更多信息）</td></tr></tbody></table><p>(表格来源于gpt的大力支持)</p>',23)]))}const p=e(l,[["render",o]]);export{u as __pageData,p as default};
